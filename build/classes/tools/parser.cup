package nachts;
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   ArrayList<String> errores = new ArrayList();
   public static Node root;
   public int cont = 1;

     public String getToken(int id){
        String value = Sym.terminalNames[id];
        switch(id){
            case Sym.L_KEY:
                return "{";
            case Sym.R_KEY:
                return "}";
            case Sym.L_PAR:
                return "(";
            case Sym.R_PAR:
                return ")";
            case Sym.L_BRACKET:
                return "[";
            case Sym.R_BRACKET:
                return "]";
            default:
                return value;
        }
    }   
    
    @Override
    public void syntax_error(Symbol s){
        String lex = s.value != null ? s.value.toString() : getToken(s.sym);
        int fila = s.right;
        int columna = s.left;
        String err = "";
        if(lex.equals("EOF")){
            err = "Error sint치ctico: Se esperaba el token }";
        } else {
            err = "Error sint치ctico: " +  " fila: " + fila + " columna: " + columna + ", No se esperaba el token: " + lex;
        }

        System.err.println(err);
        errores.add(err);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String lex = s.value != null ? s.value.toString() : getToken(s.sym);
        int fila = s.right;
        int columna = s.left;
        String err = "";
        if(lex.equals("EOF")){
            err = "";
        }else{
            err = "Error sint치ctico, p치nico: " + " fila: " + fila + " columna: " + columna + ", No se esperaba el token: " + lex;
        }
        System.err.println(err);
        errores.add(err);
    }
    

:}

terminal String FUNCTION,NUM,UPTO,DOWNTO,STEP,VARIABLE,STRING,
                CONSTSTRING,CONSTCHAR,INTEGER,CHARACTER,BOOLEAN,IF,ELSE,
                WHILE,FOR,RETURN,VOID,TRUE,FALSE,BREAK,NULL,
                INPUT,OUTPUT,SWITCH,CASE,OPTION,DEFAULT,ID,
                OPREL,OPCOND,OPLOG,OPMOD,OPMULT,OPSUM,OPINC,OPASIGN,
                OPASIGNADD,OPASIGNMULT,L_KEY,R_KEY,L_BRACKET,R_BRACKET,
                L_PAR,R_PAR,COMMA,SEMICOLON,COLON,AT,DOT,EMPTY;

non terminal Node inicio,dec_gen_fun,dec_funcion,parametros,/*lista_parametro,
             def_parametro,*/nuevo_parametro,func_lenguaje,func_input,
             func_output,dec_general,dec_variable,dec_var,dec_inst,
             arr_cont,dec_var_inst,valor,math_op,s_op,sum_op,m_op,mult_op,
             val,dec_while,dec_for,dec_switch,list_op,new_op,dec_if,
             dec_else,dec_llamada_funcion,llamada_parametros,
             lista_valores,fin_llamada,condicion,valor_cond,dec_return,
             tipo,empty;

precedence left OPSUM,OPMULT;
precedence left OPASIGN;
precedence nonassoc ELSE;
precedence left R_PAR;

start with inicio;

inicio ::= dec_funcion:dg dec_gen_fun:dgf
    {:
    System.out.println("Entra a inicio");

    Node node = new Node();
    node.setEtiqueta("INICIO");
    node.setID(parser.cont);
    node.addHijos((Node) dg);
    node.addHijos((Node) dgf);
    
    parser.root = node;
    RESULT = node; 
    
    :} ;
    
empty ::= EMPTY {:
                Node node = new Node();
                RESULT = node;
            :};

dec_gen_fun ::= dec_funcion:df dec_gen_fun:dgf
            {:
                System.err.println("Entra a dec_gen_fun");

                Node node = new Node();
                RESULT = node;
            :}
            | empty
            {:
                Node node = new Node();
                RESULT = node;
            :}
;

dec_funcion ::= FUNCTION ID L_PAR parametros COLON tipo L_KEY dec_general R_KEY
            {:
               System.err.println("Entra a dec_funcion");

                Node node = new Node();
                RESULT = node;
            :}
;

parametros ::= VARIABLE ID COLON tipo nuevo_parametro R_PAR
                {:
                Node node = new Node();
                RESULT = node;
                :}
               |VARIABLE ID COLON tipo R_PAR 
               {:
                Node node = new Node();
                RESULT = node;
               :} 
               |R_PAR
               {:
                Node node = new Node();
                RESULT = node;
               :} ;

nuevo_parametro ::=COMMA VARIABLE ID COLON tipo nuevo_parametro
                {:
                Node node = new Node();
                RESULT = node;
                :}
                | COMMA VARIABLE ID COLON tipo
                {:
                Node node = new Node();
                RESULT = node;
                :};

func_lenguaje ::= func_input
                  {:
                    Node node = new Node();
                    RESULT = node;
                  :}
                  | func_output
                  {:
                    Node node = new Node();
                    RESULT = node;
                  :}  
                  ;
                  
func_input ::= INPUT L_PAR ID COMMA tipo R_PAR SEMICOLON
               {:
                Node node = new Node();
                RESULT = node;
                :}
                ;

func_output ::= OUTPUT L_PAR CONSTSTRING R_PAR SEMICOLON 
                {:
                Node node = new Node();
                RESULT = node;
                :}    
                | OUTPUT L_PAR NUM R_PAR SEMICOLON
                {:
                Node node = new Node();
                RESULT = node;
                :}
                | OUTPUT L_PAR ID R_PAR SEMICOLON 
                {:
                Node node = new Node();
                RESULT = node;
                :}    
                ;

dec_general ::= dec_variable dec_general:dg
               {:
                Node node = new Node();
                RESULT = node;
               :}
               | dec_var dec_general
               {:
                Node node = new Node();
                RESULT = node;
               :}
               | dec_while dec_general
               {:
                Node node = new Node();
                RESULT = node;
                :}
               | dec_for dec_general
               {:
                Node node = new Node();
                RESULT = node;
                :}
               | dec_switch dec_general
                {:
                Node node = new Node();
                RESULT = node;
                :} 
               |dec_if dec_general
               {:
                Node node = new Node();
                RESULT = node;
               :}
               |dec_llamada_funcion SEMICOLON dec_general
               {:
                Node node = new Node();
                RESULT = node;
               :}
               |dec_var_inst dec_general
               {:
                Node node = new Node();
                RESULT = node;
                :}
               |func_lenguaje dec_general
               {:
                Node node = new Node();
                RESULT = node;
                :}
               | dec_return
                {:
                Node node = new Node();
                RESULT = node;
                :}
                ;

dec_variable ::= VARIABLE ID COLON tipo dec_var 
                 {:
                Node node = new Node();
                RESULT = node;
                :}   
                | VARIABLE ID L_BRACKET NUM R_BRACKET COLON tipo dec_inst dec_var 
                {:
                Node node = new Node();
                RESULT = node;
                :}
                ;

dec_var ::= dec_inst SEMICOLON
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | COMMA ID COLON tipo dec_inst dec_var
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | COMMA ID L_BRACKET NUM R_BRACKET COLON tipo dec_inst dec_var 
            {:
                Node node = new Node();
                RESULT = node;
            :}
;

dec_inst ::= OPASIGN ID
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN ID DOT AT L_PAR NUM R_PAR
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN NUM 
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN CONSTSTRING
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN CONSTCHAR  
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN TRUE
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN FALSE 
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN dec_llamada_funcion 
             {:
                Node node = new Node();
                RESULT = node;
             :}
             | OPASIGN L_KEY valor arr_cont R_KEY 
             {:
                Node node = new Node();
                RESULT = node;
             :}
             |empty
             {:
                Node node = new Node();
                RESULT = node;
             :}
              ;

arr_cont ::= COMMA valor arr_cont
             {:
                Node node = new Node();
                RESULT = node;
            :}
            |empty
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_var_inst ::= ID OPASIGN valor SEMICOLON
                {:
                Node node = new Node();
                RESULT = node;
                :}
                | ID DOT AT L_PAR NUM R_PAR OPASIGN valor SEMICOLON
                {:
                Node node = new Node();
                RESULT = node;
                :}
                ;

valor ::=  CONSTSTRING
           {:
                Node node = new Node();
                RESULT = node;
           :}
           | CONSTCHAR
           {:
                Node node = new Node();
                RESULT = node;
           :}
           | TRUE
           {:
                Node node = new Node();
                RESULT = node;
           :}
           | FALSE
           {:
                Node node = new Node();
                RESULT = node;
           :}
           | math_op
           {:
                Node node = new Node();
                RESULT = node;
           :} 
            ;

math_op ::= s_op 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | m_op
            ;

s_op ::= val sum_op 
            {:
                Node node = new Node();
                RESULT = node;
            :};

sum_op ::= OPSUM val sum_op
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | OPSUM val mult_op
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | OPSUM val
            {:
                Node node = new Node();
                RESULT = node;
            :} 
            ;

m_op ::= val mult_op 
            {:
                Node node = new Node();
                RESULT = node;
            :};
            
mult_op ::= OPMULT val mult_op 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | OPMULT val sum_op 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | OPMULT val
            {:
                Node node = new Node();
                RESULT = node;
            :} 
            ;

val ::= ID
        {:
                Node node = new Node();
                RESULT = node;
        :}
        | NUM
        {:
                Node node = new Node();
                RESULT = node;
        :}
        | dec_llamada_funcion 
        {:
                Node node = new Node();
                RESULT = node;
        :}
        | L_PAR math_op R_PAR 
        {:
                Node node = new Node();
                RESULT = node;
        :}
        ;

dec_while ::= WHILE L_PAR condicion R_PAR L_BRACKET dec_general R_BRACKET
            {:
                Node node = new Node();
                RESULT = node;
            :}
;

dec_for ::= FOR L_PAR ID COMMA NUM UPTO COMMA STEP L_PAR NUM R_PAR R_PAR L_KEY dec_general R_KEY
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | FOR L_PAR ID COMMA NUM DOWNTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | FOR L_PAR VARIABLE ID COLON INTEGER COMMA NUM UPTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | FOR L_PAR VARIABLE ID COLON INTEGER COMMA NUM DOWNTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_switch ::= SWITCH L_PAR ID R_PAR L_BRACKET list_op R_BRACKET 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

list_op ::= OPTION valor COLON dec_general new_op 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

new_op ::= BREAK SEMICOLON list_op 
            | BREAK SEMICOLON DEFAULT COLON dec_general
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | BREAK SEMICOLON 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_if ::= IF L_PAR condicion R_PAR L_KEY dec_general R_KEY dec_else 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_else ::= ELSE dec_if 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | ELSE L_KEY dec_general R_KEY 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | empty
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_llamada_funcion ::= ID L_PAR llamada_parametros 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

llamada_parametros ::= valor lista_valores R_PAR
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | valor R_PAR
            {:
                Node node = new Node();
                RESULT = node;
            :}
            |R_PAR
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

lista_valores ::= COMMA valor lista_valores
            {:
                Node node = new Node();
                RESULT = node;
            :}
            |COMMA valor
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;


condicion ::= valor_cond OPREL valor_cond 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | valor_cond OPREL valor_cond OPLOG condicion 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | valor_cond 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | NULL 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | valor_cond OPLOG condicion 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

valor_cond ::= NUM
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | ID
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | TRUE
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | FALSE 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

dec_return ::= RETURN dec_llamada_funcion
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | RETURN SEMICOLON
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | RETURN valor SEMICOLON  
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;

tipo ::= BOOLEAN
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | CHARACTER 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | INTEGER
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | VOID
            {:
                Node node = new Node();
                RESULT = node;
            :}
            | STRING 
            {:
                Node node = new Node();
                RESULT = node;
            :}
            ;