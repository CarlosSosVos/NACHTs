package nachts;
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   ArrayList<String> errores = new ArrayList();
   
     public String getToken(int id){
        String value = Sym.terminalNames[id];
        switch(id){
            case Sym.L_KEY:
                return "{";
            case Sym.R_KEY:
                return "}";
            case Sym.L_PAR:
                return "(";
            case Sym.R_PAR:
                return ")";
            case Sym.L_BRACKET:
                return "[";
            case Sym.R_BRACKET:
                return "]";
            default:
                return value;
        }
    }   

    @Override
    public void syntax_error(Symbol s){
        String lex = s.value != null ? s.value.toString() : getToken(s.sym);
        int fila = s.right;
        int columna = s.left;
        String err = "";
        if(lex.equals("EOF")){
            err = "Error sint치ctico: Se esperaba el token }";
        } else {
            err = "Error sint치ctico: " +  " fila: " + fila + " columna: " + columna + ", No se esperaba el token: " + lex;
        }

        System.err.println(err);
        errores.add(err);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String lex = s.value != null ? s.value.toString() : getToken(s.sym);
        int fila = s.right;
        int columna = s.left;
        String err = "";
        if(lex.equals("EOF")){
            err = "";
        }else{
            err = "Error sint치ctico, p치nico: " + " fila: " + fila + " columna: " + columna + ", No se esperaba el token: " + lex;
        }
        System.err.println(err);
        errores.add(err);
    }


:}

terminal String FUNCTION,NUM,UPTO,DOWNTO,STEP,VARIABLE,STRING,
                CONSTSTRING,CONSTCHAR,INTEGER,CHARACTER,BOOLEAN,IF,ELSE,
                WHILE,FOR,RETURN,VOID,TRUE,FALSE,BREAK,NULL,
                INPUT,OUTPUT,SWITCH,CASE,OPTION,DEFAULT,ID,
                OPREL,OPCOND,OPLOG,OPMOD,OPMULT,OPSUM,OPINC,OPASIGN,
                OPASIGNADD,OPASIGNMULT,L_KEY,R_KEY,L_BRACKET,R_BRACKET,
                L_PAR,R_PAR,COMMA,SEMICOLON,COLON,AT,DOT;

non terminal inicio,dec_gen_fun,dec_funcion,parametros,/*lista_parametro,
             def_parametro,*/nuevo_parametro,func_lenguaje,func_input,
             func_output,dec_general,dec_variable,dec_var,dec_inst,
             arr_cont,dec_var_inst,valor,math_op,sum_op,m_op,mult_op,
             val,dec_while,dec_for,dec_switch,list_op,new_op,dec_if,
             dec_else,dec_llamada_funcion,llamada_parametros,
             lista_valores,fin_llamada,condicion,valor_cond,dec_return,
             tipo;

precedence left OPSUM,OPMULT;
precedence left OPASIGN;

start with inicio;

inicio ::= dec_general dec_gen_fun;

dec_gen_fun ::= dec_funcion dec_gen_fun | ;

dec_funcion ::= FUNCTION ID L_PAR parametros R_PAR COLON tipo L_KEY dec_general dec_return R_KEY;

/*parametros ::= lista_parametro | ;

lista_parametro ::= def_parametro | ;

def_parametro ::= VARIABLE ID COLON tipo nuevo_parametro ;*/

parametros ::= VARIABLE ID COLON tipo nuevo_parametro | ;

nuevo_parametro ::=COMMA VARIABLE ID COLON tipo nuevo_parametro | ;

func_lenguaje ::= func_input | func_output;

func_input ::= INPUT L_PAR ID COMMA tipo R_PAR SEMICOLON ;

func_output ::= OUTPUT L_PAR CONSTSTRING R_PAR SEMICOLON | OUTPUT L_PAR NUM R_PAR SEMICOLON | OUTPUT L_PAR ID R_PAR SEMICOLON ;

dec_general ::= dec_variable dec_general | dec_var dec_general | dec_while dec_general | dec_for dec_general | dec_switch dec_general | dec_if dec_general | dec_llamada_funcion dec_general |dec_var_inst dec_general|func_lenguaje dec_general| ;

dec_variable ::= VARIABLE ID COLON tipo dec_var | VARIABLE ID L_BRACKET NUM R_BRACKET COLON tipo dec_inst dec_var ;

dec_var ::= dec_inst SEMICOLON | COMMA ID COLON tipo dec_inst dec_var | COMMA ID L_BRACKET NUM R_BRACKET COLON tipo dec_inst dec_var ;

dec_inst ::= OPASIGN ID | OPASIGN ID DOT AT L_PAR NUM R_PAR | OPASIGN NUM | OPASIGN CONSTSTRING | OPASIGN CONSTCHAR  | OPASIGN TRUE | OPASIGN FALSE | OPASIGN dec_llamada_funcion | OPASIGN L_KEY valor  arr_cont R_KEY | ;

arr_cont ::= COMMA valor arr_cont | ;

dec_var_inst ::= ID OPASIGN valor SEMICOLON| ID DOT AT L_PAR NUM R_PAR OPASIGN valor SEMICOLON;

valor ::=  CONSTSTRING | CONSTCHAR | TRUE | FALSE | math_op ;

math_op ::= m_op sum_op ;

sum_op ::= OPSUM m_op sum_op | ;

m_op ::= val mult_op ;

mult_op ::= OPMULT val mult_op | ;

val ::= ID | NUM | dec_llamada_funcion | L_PAR math_op R_PAR ;

dec_while ::= WHILE L_PAR condicion R_PAR L_BRACKET dec_general R_BRACKET ;

dec_for ::= FOR L_PAR ID COMMA NUM UPTO COMMA STEP L_PAR NUM R_PAR R_PAR L_KEY dec_general R_KEY | FOR L_PAR ID COMMA NUM DOWNTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET | FOR L_PAR VARIABLE ID COLON INTEGER COMMA NUM UPTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET | FOR L_PAR VARIABLE ID COLON INTEGER COMMA NUM DOWNTO NUM COMMA STEP L_PAR NUM R_PAR R_PAR L_BRACKET dec_general R_BRACKET ;

dec_switch ::= SWITCH L_PAR ID R_PAR L_BRACKET list_op R_BRACKET ;

list_op ::= OPTION valor COLON dec_general new_op ;

new_op ::= BREAK SEMICOLON list_op | BREAK SEMICOLON DEFAULT COLON dec_general | BREAK SEMICOLON ;

dec_if ::= IF L_PAR condicion R_PAR L_KEY dec_general R_KEY dec_else ;

dec_else ::= ELSE dec_if | ELSE L_KEY dec_general R_KEY | ;

dec_llamada_funcion ::= ID L_PAR llamada_parametros R_PAR fin_llamada ;

llamada_parametros ::= valor lista_valores | ;

lista_valores ::= COMMA valor | ;

fin_llamada ::= SEMICOLON ;

condicion ::= valor_cond OPREL valor_cond | valor_cond OPREL valor_cond OPLOG condicion | valor_cond | NULL | valor_cond OPLOG condicion ;

valor_cond ::= NUM | ID | TRUE | FALSE ;

dec_return ::= RETURN dec_llamada_funcion | RETURN SEMICOLON | RETURN valor SEMICOLON  ;

tipo ::= BOOLEAN | CHARACTER | INTEGER | VOID | STRING ;